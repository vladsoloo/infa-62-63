### Соломахин Владислав
### Параграф 62 

1. Что такое массив? Зачем нужны массивы?  

Массив – это структура данных, позволяющая хранить несколько значений одинакового типа. Массивы необходимы для упрощения работы с набором данных, чтобы иметь возможность обращаться к ним по индексу и управлять ими эффективно.

2. Зачем нужно объявлять массивы? 

Объявление массивов нужно для определения их размера и типа содержимого, а также для выделения памяти для хранения элементов массива.

3. Как объявляются массивы в школьном алгоритмическом языке и в Паскале?

В школьном алгоритмическом языке:  
Массив A[1..N] - целые числа  

В Паскале:  
var  
  A: array[1..N] of Integer;

В Python массивы (или списки) объявляются просто, без указания размера:  
A = [0] * N  # создание списка с N нулевыми элементами

4. Как вы думаете, почему элементы массива расположены в памяти рядом?

Элементы массива располагаются в памяти рядом для оптимизации доступа к ним. Это позволяет эффективно использовать кеширование и сокращает время доступа к элементам.

5. Как обращаются к элементу массива?

К элементу массива обращаются по его индексу. Например, в Python:  
A[0]  # доступ к первому элементу массива (индексация начинается с 0)

6. Могут ли индексы элементов массива начинаться с 0? С -5?

В Python индексы всегда начинаются с 0. Индексация с -5 возможна, так как в Python отрицательные индексы обозначают доступ к элементам с конца списка:  
A[-1]  # последний элемент массива

7. Почему размер массива лучше вводить как константу, а не как число?

Использование константы для размера массива упрощает управление и модификацию кода. При необходимости изменения размера массива это можно сделать в одном месте, избегая поиска и изменений по всему коду.

8. Как ввести массив и вывести его на экран?

Для ввода и вывода массива в Python можно использовать следующие коды:  

N = int(input("Введите размер массива: "))
A = [0] * N

for i in range(N):
    A[i] = int(input(f"Введите элемент {i + 1}: "))

print("Элементы массива:", A)
```

9. Как заполнить массив случайными числами в диапазоне от 100 до 200? 

Для заполнения массива случайными числами в Python:  

import random

N = int(input("Введите размер массива: "))
A = [random.randint(100, 200) for _ in range(N)]

print("Массив с случайными числами:", A)

! ЗАДАЧИ !

1. Заполните массив элементами арифметической прогрессии. Ее первый элемент и разность нужно ввести с клавиатуры.

n = int(input("Введите количество элементов: "))
a = int(input("Введите первый элемент: "))
d = int(input("Введите разность: "))
A = []

for i in range(n):
    A.append(a + i * d)


2. Заполните массив степенями числа 2 (от 2^1 до 2^N).

N = int(input("Введите количество элементов: "))
A = [2**i for i in range(1, N+1)]


3. Заполните массив первыми числами Фибоначчи.

N = int(input("Введите количество элементов: "))
A = [0, 1]
for i in range(2, N):
    a_i = A[i-1] + A[i-2]
    A.append(a_i)


4. Заполните массив из N элементов случайными целыми числами в диапазоне 1..N так, чтобы в массив обязательно вошли все числа от 1 до N (постройте случайную перестановку).

import random

N = int(input("Введите количество элементов: "))
A = [i for i in range(1, N+1)]
random.shuffle(A)


5. Постройте случайную перестановку чисел от 1 до N так, чтобы первое число обязательно было равно 5 (N ≥ 5).

import random

N = int(input("Введите количество элементов: "))
A = [i + 4 for i in range(1, N)]
A.insert(0, 5)
random.shuffle(A)


6. Заполните массив случайными числами в диапазоне 20..100 и подсчитайте отдельно число элементов с четными и нечетными значениями.

import random

N = int(input("Введите количество элементов: "))
A = [random.randint(20, 100) for i in range(N)]
even_count = len([i for i in A if i % 2 == 0])  # Число четных элементов
odd_count = len(A) - even_count  # Число нечетных элементов


7. Заполните массив случайными числами в диапазоне 1000..2000 и подсчитайте число элементов, у которых вторая с конца цифра четная.

import random

N = int(input("Введите количество элементов: "))
A = [random.randint(1000, 2000) for i in range(N)]
even_count = len([i for i in A if (i // 10 % 10) % 2 == 0])  # Число элементов с четной цифрой


8. Заполните массив случайными числами в диапазоне 0..100 и подсчитайте отдельно среднее значение всех элементов, меньших 50, и среднее значение всех элементов, которые больше или равны 50.

подзабыл 


 Урок 63

1. Почему при поиске индекса максимального элемента необязательно хранить само значение максимального элемента?  

При поиске индекса максимального элемента достаточно хранить только индекс, потому что его можно использовать для доступа к элементу в массиве. Если мы уже знаем индекс, то можем сразу обратиться к массиву и получить значение элемента. Это экономит память и упрощает исходный алгоритм.

2. Что такое реверс массива? 

Реверс массива – это операция, при которой порядок элементов массива меняется на обратный. То есть первый элемент становится последним, второй — предпоследним и так далее.

3. Как вы думаете, какую ошибку чаще всего делают начинающие программисты, программируя реверс массива?  

Начинающие программисты могут забывать о необходимости завершить процесс до достижения середины массива или неправильно рассчитывать индексы, что может привести к перезаписи элементов или выходу за границы массива.

4. Как вы думаете, какие проблемы (и ошибки) могут возникнуть при циклическом сдвиге массива вправо?  

При циклическом сдвиге вправо возможны следующие проблемы:
- Перезапись исходных данных, так как сдвигаемые элементы могут затереть значения, которые еще не были сдвинуты.
- Ошибка при работе с границами массива, например, если не учтены индексы, что может привести к выходу за границы.

5. Что произойдёт с массивом при выполнении следующего фрагмента программы?  

Фрагмент программы имеет неопределённое поведение, поскольку при каждом запуске выполняется присваивание A1+1 = A1, и это будет бесконечный цикл, если только не добавлен выход из него. В конечном итоге, если этот фрагмент выполняется в контексте программы без предусловий, массив останется неизменным или закончится выполнением с ошибкой.

6. Как при использовании приведённого алгоритма поиска определить, что элемент не найден?  

Чтобы определить, что элемент не найден, нужно после завершения поиска проверить, было ли сделано успешное сравнение или изменение индекса. Если индекс не изменился или остался равным первоначальному значению, элемент считается не найденным.

7. Что такое выход за границы массива? Почему он может быть опасен?  

Выход за границы массива происходит, когда происходит попытка доступа к элементу по индексу, который либо меньше 0, либо больше (или равен) размеру массива. Это может быть опасно, потому что может привести к повреждению данных, некорректным результатам или аварийному завершению программы.

8. Опишите «очевидный» алгоритм отбора части элементов одного массива в другой массив. Почему его не используют?  

«Очевидный» алгоритм может выглядеть следующим образом:

1. Создать новый массив с нужным размером.
2. Итерировать по элементам первого массива.
3. Копировать элементы в новый массив на основе заданного условия.

Код на Python:
original_array = [1, 2, 3, 4, 5, 6, 7, 8, 9]
selected_elements = []
for i in range(len(original_array)):
    if original_array[i] % 2 == 0:  # выбираем только четные элементы
        selected_elements.append(original_array[i])


! ЗАДАЧИ !

1. Напишите программу, которая находит максимальный и минимальный из элементов массива с чётными положительными значениями. Если в массиве нет элементов с чётными положительными значениями, нужно вывести сообщение об этом.

def find_min_max_even_positive(arr):
    even_positive_numbers = [num for num in arr if num > 0 and num % 2 == 0]
    
    if not even_positive_numbers:
        return "Нет элементов с чётными положительными значениями"
    
    return min(even_positive_numbers), max(even_positive_numbers)

array = [1, -2, 3, 4, 5, 6, -10, 2]
result = find_min_max_even_positive(array)
print(result)


2. Введите массив с клавиатуры и найдите (за один проход) количество элементов, имеющих максимальное значение.

array = list(map(int, input("Введите элементы массива через пробел: ").split()))
max_value = max(array)
count_max = sum(1 for x in array if x == max_value)
print("Количество элементов с максимальным значением:", count_max)


3. Найдите за один проход по массиву три его различных элемента, которые меньше всех остальных («три минимума»).

def find_three_minima(arr):
    unique_arr = list(set(arr))
    unique_arr.sort()
    
    return unique_arr[:3] if len(unique_arr) >= 3 else unique_arr

array = [8, 3, 1, 6, 2, 4, 1, 7]
result = find_three_minima(array)
print("Три минимума:", result)


4. Заполните массив случайными числами в диапазоне 10..12 и найдите длину самой длинной последовательности стоящих рядом элементов с одинаковыми значениями.

import random

array = [random.randint(10, 12) for _ in range(20)]
max_length = current_length = 1

for i in range(1, len(array)):
    if array[i] == array[i - 1]:
        current_length += 1
        max_length = max(max_length, current_length)
    else:
        current_length = 1

print("Массив:", array)
print("Длина самой длинной последовательности:", max_length)


5. Заполните массив случайными числами в диапазоне 0..4 и выведите на экран номера всех элементов, значение которых равно х (Х вводится с клавиатуры).

x = int(input("Введите число x (от 0 до 4): "))
array = [random.randint(0, 4) for _ in range(20)]
indexes = [i for i, value in enumerate(array) if value == x]

print("Массив:", array)
print("Индексы элементов, равных x:", indexes)


6. Заполните массив случайными числами и переставьте соседние элементы, поменяв 1-й элемент со 2-м, 3-й с 4-м и т. д.

array = [random.randint(0, 100) for _ in range(10)]
for i in range(0, len(array) - 1, 2):
    array[i], array[i + 1] = array[i + 1], array[i]

print("Перемешанный массив:", array)


7. Заполните массив с чётным количеством элементов случайными числами и выполните реверс отдельно для первой и второй половин массива.

array = [random.randint(1, 100) for _ in range(10)]
mid = len(array) // 2

array[:mid] = reversed(array[:mid])
array[mid:] = reversed(array[mid:])

print("Реверсированный массив:", array)


8. Заполните массив случайными числами и выполните реверс для части массива между элементами с индексами к и м (включая эти элементы).

k = int(input("Введите индекс k: "))
m = int(input("Введите индекс m: "))
array = [random.randint(1, 100) for _ in range(10)]

array[k:m+1] = reversed(array[k:m+1])
print("Массив после реверса:", array)


9. Напишите программу для выполнения циклического сдвига массива вправо на 4 элемента.

array = [random.randint(1, 100) for _ in range(10)]
n = len(array)
shift = 4

shifted_array = array[-shift:] + array[:-shift]
print("Массив после циклического сдвига вправо:", shifted_array)


10. Найдите в массиве все простые числа и скопируйте их в новый массив.

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

array = [random.randint(1, 100) for _ in range(20)]
primes = [num for num in array if is_prime(num)]

print("Массив:", array)
print("Простые числа:", primes)


11. Найдите в массиве все числа Фибоначчи и скопируйте их в новый массив.

def fibonacci_numbers(n):
    fibs = [0, 1]
    while fibs[-1] < n:
        fibs.append(fibs[-1] + fibs[-2])
    return set(fibs)

array = [random.randint(0, 100) for _ in range(20)]
fib_set = fibonacci_numbers(100)
fibonacci_in_array = [num for num in array if num in fib_set]

print("Массив:", array)
print("Числа Фибоначчи:", fibonacci_in_array)
